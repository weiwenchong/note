## new和make区别

## GMP模型

## GC
### 三色标记法
go目前使用三色标记法.
1. 起初所有对象都是白色.
2. 从根出发,扫描所有可达对象,标记为灰色,放入待处理队列.
3. 从队列中取出灰色对象,将其引用对象标为灰色放入队列,自身标记为黑色.
4. 重复3,直到灰色对象队列为空,此时白色对象即为垃圾,进行回收.
#### 好处
可以让用户程序和标记并发进行
### 历史
* 1.3以前.  
STW(stop the world),标记和清除都是暂停所有任务,会导致卡顿.
* 1.3.  
标记 STW,清除 并行.
* 1.5.  
三色标记法,渐进标记而不是每次扫描整个内存,减少STW时间.
* 1.8.  
写屏障,如果对象引用有变动,就将其放入灰色.

## channel
### channel为nil和已关闭读写会发生什么
|chan状态|active|nil|close|
|---|---|---|---|
|读|正常|阻塞|能读取到未取出的消息,读完后是零值|
|写|正常|阻塞|panic|
|关闭|正常|panic|panic|
### channel的使用
[由浅入深剖析channel](https://www.jianshu.com/p/24ede9e90490)
### channel底层
环形数组实现的队列.


## 内存逃逸
不被外部引用的局部变量一般放在栈上,函数返回后不用gc,返还内存给系统,需要外部引用的会放在堆上.
### 逃逸分析
编译器决定内存分配的位置,不需要程序员指定.
### 逃逸场景
1. 指针逃逸.
2. 栈空间不足逃逸(对象占内存过大).
3. 动态类型逃逸.
4. 闭包引用对象逃逸.

## goroutine栈内存
每个goroutine都维护一个自己的栈区,只能自己使用不能被别的goroutine使用.初始内存大小为2kb,相比之下线程的默认栈大小是2m,在goroutine运行时栈区会根据需要增长和收缩,最大内存默认为1G.

## 协程和线程切换
协程切换比线程快主要是两点:
1. 协程切换完全在用户态进行,线程需要在内核空间完成.
2. 协程切换比线程切换做的事更少.
### 协程切换
只涉及基本的cpu上下文切换,把当前协程的cpu寄存器状态保存起来,将切换进来的协程的CPU寄存器状态加载到CPU寄存器上就行了,完全在用户态进行,一般是几十ns这个量级.
### 线程切换
线程调度必须要切换到内核空间才可以完成,除了基本的CPU上下文,还需要有线程私有的栈和寄存器.
