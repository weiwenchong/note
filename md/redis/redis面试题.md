## 单线程
### 为什么用单线程

## 缓存穿透|击穿|雪崩
### 穿透
缓存和数据库里都没有的数据,用户不断发起请求,导致db压力大.  
解决方法: 1.增加校验,将不合格id直接阻拦(如id<0);2.将不存在的id也写到缓存里,写为null,设置的存在时间短一点.
### 击穿
缓存里没有,但数据库里有的数据(一般是缓存到期),此时大量用户请求数据,导致数据库压力大.  
解决方法: 1.设置热点数据永不过期. 2.根据key设置互斥锁,同时只有一个能去拿,没拿到锁的等待100ms.
### 雪崩
缓存里的数据大量过期,而查询数量很大,导致大量请求进入数据库,与击穿不同,缓存击穿是并发查同一条数据,雪崩是多条数据都过期.
解决方法: 1.过期时间设置随机.2.

## redis的部署模式
1. 单机.
2. 主从. 实现了读写分离,但并不高可用.主服务器宕机后需要手动切换.
2. 哨兵. 主从模式的高可用版本,哨兵来完成主机宕机后的切换操作.
3. 集群. 不仅提供了高可用,而且数据分片保存在各个节点中,可以支持高并发的写入和读取.每个分片上有多个节点组成主从,使用一致性哈希等算法进行分片.
4. codis. 默认将key划分为1024个槽位(数量可以修改),每个槽位后对应多个redis实例,将key进行hash运算后对1024取模得到对应key的槽位. 可以启动多个codis实例来支撑高qps,同时也起到了容灾. 使用zookeeper来存储槽位关系.

## redis分布式锁
### setnx
```shell
set key value NX PX 3000
# NX表示if not exist PX表示时间用毫秒级
```
释放需要使用lua脚本.  
这种模式最大的缺点是只能作用在一个redis节点上,即使通过哨兵来保证高可用,一样有可能导致锁丢失.例如,在redis的master上拿到锁后,还没同步到slave,master故障转移,升级一个slave为master,会导致锁丢失.
### redlock
假设有N个完全独立的redis主服务器.
1. 获取当前时间戳.
2. 客户端尝试按顺序使用相同的key,value获取所有redis服务的锁,获取时间要比锁过期时间短的多,例如过期时间为m,那获取一个锁最多m/N,获取不到就放弃,尝试下一个.
3. 客户端获取所有锁后,使用当前时间减去一开始的时间戳,这个时间差要小于redis过期时间并且至少有N/2+1个实例获取到锁,这样算获取锁成功.
4. 如果获取锁成功,那锁的有效时间是过期时间减去获取所有锁的用时.
5. 如果客户端因为某些原因获取锁失败,会开始解锁所有的redis实例,不能影响其他请求上锁.
